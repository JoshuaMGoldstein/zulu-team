<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Client</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #ffffff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #cccccc;
            font-size: 14px;
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 10px;
            background-color: #2d2d2d;
            border: 1px solid #555;
            color: #ffffff;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        input[type="text"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: #0078d4;
        }
        
        .terminal {
            background-color: #0c0c0c;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .terminal .output {
            color: #ffffff;
        }
        
        .terminal .error {
            color: #ff6b6b;
        }
        
        .terminal .system {
            color: #4ec9b0;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 10px 20px;
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        button:hover:not(:disabled) {
            background-color: #106ebe;
        }
        
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        
        .message-input {
            margin-top: 15px;
        }
        
        .command-input {
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Terminal Client</h1>
        
        <div class="input-group">
            <label for="apiKey">OPENAI_API_KEY:</label>
            <input type="password" id="apiKey" placeholder="Enter your OpenAI API key...">
        </div>
        
        <div class="command-input">
            <label for="command">Command:</label>
            <input type="text" id="command" value="gemini --model 'kimi-k2-turbo-preview' --prompt '{message}'">
        </div>
        
        <div class="message-input">
            <label for="message">Message:</label>
            <input type="text" id="message" placeholder="Enter your message..." onkeypress="handleKeyPress(event)">
        </div>
        
        <div class="terminal" id="terminal">
            <div class="system">Terminal ready. Click "WS Connect" to establish connection.</div>
        </div>
        
        <div class="button-group">
            <button id="connectBtn" onclick="connectWebSocket()">WS Connect</button>
            <button id="wsExecBtn" onclick="sendWsExec()" disabled>WS Exec</button>
            <button id="postExecBtn" onclick="sendPostExec()" disabled>POST Exec</button>
        </div>
        
        <div class="input-group">
            <label for="stdin">STDIN:</label>
            <input type="text" id="stdin" placeholder="Enter input for running process..." onkeypress="handleStdinKeyPress(event)">
        </div>
    </div>

    <script>
        let ws = null;
        let clientId = '';
        let instanceId = '';
        let activeProcesses = new Map(); // Track active processes for stdin

        function generateRandomId(length = 8) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function escapeSingleQuotes(str) {
            return str.replace(/'/g, "'\"'\"'");
        }

        function addToTerminal(text, className = 'output') {
            const terminal = document.getElementById('terminal');
            
            // Find the last output element
            const lastOutput = terminal.lastElementChild;
            
            // If the last element is of the same class and doesn't end with newline, append to it
            if (lastOutput && lastOutput.className === className && !lastOutput.dataset.endsWithNewline) {
                lastOutput.textContent += text;
            } else {
                // Create new element
                const div = document.createElement('div');
                div.className = className;
                div.textContent = text;
                terminal.appendChild(div);
            }
            
            // Check if text ends with newline and mark accordingly
            if (text.endsWith('\n')) {
                const currentLast = terminal.lastElementChild;
                if (currentLast) {
                    currentLast.dataset.endsWithNewline = 'true';
                }
            }
            
            terminal.scrollTop = terminal.scrollHeight;
        }

        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            clientId = generateRandomId();
            instanceId = generateRandomId();
            
            const wsUrl = `/ws?clientid=${clientId}&instanceid=${instanceId}`;
            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                addToTerminal('WS Connection Established', 'system');
                document.getElementById('connectBtn').textContent = 'WS Disconnect';
                document.getElementById('connectBtn').onclick = disconnectWebSocket;
                document.getElementById('wsExecBtn').disabled = false;
                document.getElementById('postExecBtn').disabled = false;
            };

            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if (data.type === 'stdout') {
                    addToTerminal(data.data, 'output');
                } else if (data.type === 'stderr') {
                    addToTerminal(data.data, 'error');
                } else if (data.type === 'stdclose') {
                    addToTerminal(`Process ${data.pid} closed: ${data.data}`, 'system');
                    activeProcesses.delete(data.pid);
                } else if (data.type === 'open') {
                    addToTerminal(`Process started with PID: ${data.pid}`, 'system');
                    activeProcesses.set(data.pid, { clientId: clientId });
                } else if (data.error) {
                    addToTerminal(`Error: ${data.error}`, 'error');
                }
            };

            ws.onclose = function() {
                addToTerminal('WS Connection Closed', 'system');
                document.getElementById('connectBtn').textContent = 'WS Connect';
                document.getElementById('connectBtn').onclick = connectWebSocket;
                document.getElementById('wsExecBtn').disabled = true;
                document.getElementById('postExecBtn').disabled = true;
            };

            ws.onerror = function(error) {
                addToTerminal('WS Connection Error', 'error');
            };
        }

        function disconnectWebSocket() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        function buildCommand() {
            const message = document.getElementById('message').value;
            const commandTemplate = document.getElementById('command').value;
            return commandTemplate.replace('{message}', escapeSingleQuotes(message));
        }

        function sendWsExec() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addToTerminal('WebSocket not connected', 'error');
                return;
            }

            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                addToTerminal('Please enter OPENAI_API_KEY', 'error');
                return;
            }

            const command = buildCommand();
            const message = {
                type: "exec",
                command: command,
                env: {
                    GEMINI_API_KEY: "nonsense",
                    OPENAI_BASE_URL: "https://api.moonshot.ai/v1",
                    OPENAI_API_KEY: apiKey
                }
            };

            ws.send(JSON.stringify(message));
            addToTerminal(`> ${command}`, 'system');
        }

        async function sendPostExec() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                addToTerminal('Please enter OPENAI_API_KEY', 'error');
                return;
            }

            const command = buildCommand();
            const message = {
                clientid: clientId || generateRandomId(),
                command: command,
                env: {
                    GEMINI_API_KEY: "nonsense",
                    OPENAI_BASE_URL: "https://api.moonshot.ai/v1",
                    OPENAI_API_KEY: apiKey
                }
            };

            try {
                addToTerminal(`POST> ${command}`, 'system');
                const response = await fetch('/exec', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(message)
                });

                const data = await response.json();
                if (data.error) {
                    addToTerminal(`POST Error: ${data.error}`, 'error');
                } else {
                    addToTerminal(`POST Process started with PID: ${data.pid}`, 'system');
                }
            } catch (error) {
                addToTerminal(`POST Error: ${error.message}`, 'error');
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    sendWsExec();
                } else {
                    sendPostExec();
                }
            }
        }

        function handleStdinKeyPress(event) {
            if (event.key === 'Enter') {
                const stdinInput = document.getElementById('stdin');
                const input = stdinInput.value;
                if (!input || !ws || ws.readyState !== WebSocket.OPEN) {
                    return;
                }

                // Find the last process PID (simplified - assumes last started process)
                let lastPid = null;
                activeProcesses.forEach((info, pid) => {
                    lastPid = pid;
                });

                if (lastPid) {
                    const message = {
                        type: "stdin",
                        data: input,
                        pid: lastPid
                    };
                    ws.send(JSON.stringify(message));
                    stdinInput.value = '';
                }
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Set focus to message input
            document.getElementById('message').focus();
        });
    </script>
</body>
</html>